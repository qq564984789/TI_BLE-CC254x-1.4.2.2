OSAL 的英文全名称叫做 “OS Abstraction Layer ” ， 翻译成中文的意思为“系统抽象层” ，
 这样生硬的翻译可能会令大家觉得生疏难懂，我们暂且认为它就是一个简单的“操作系统”吧，
 其实这个“操作系统” ，诞生于 TI 发布 zigbee 系列芯片时期，要回到 2005 年，
 那个时候 TI 就已经发布了 OSAL 的 release1.0 版本，经过历时 10 多年的发展，目前这一套
OSAL 已经非常成熟。TI 已经提供了封装好 driver,提供 HAL 层， 绝大部分我们都不需要修改



任何 8051 单片机 c 程序， 都是由 main 函数开始的，我们拿到一份代码，首先需要找
到 main 函数：



osal_start_system:
osal 操作系统启动，实际上是一个大循环，检查相对应的标志位，就指定相对应的任务。




OSAL 里使用了一个 1ms 的节拍器作为系统定时器，这个定时器是可配置的




事件:  按键事件、定时中断事件、无线数据到达事件
所有的事件都会被安排到不同的任务里执行。
比如按键、LED、  sleep timer被安排在hal任务中，而无线数据的底层收发在LL层



OSAL (Operating System Abstraction Layer)，翻译为“操作系统抽象层”。
OSAL就是一种支持多任务运行的系统资源分配机制。
OSAL与标准的操作系统还是有很大的区别的。简单而言，OSAL实现了类似操作系统的某些功能，但并不能称之为真正意义上的操作系统。

每个用户APP.c文件主要负责写两个函数 :xInit   、xProcessEvent  。例如simpleBLEPeripheral.c文件中
SimpleBLEPeripheral_Init是任务的初始化函数，而SimpleBLEPeripheral_ProcessEvent则负责处理传递给此任务的事件(此函数的主要功能是判断由参数传递的事件类型，然后执行相应的事件处理函数)。


当有一个事件发生的时候，OSAL负责将此事件分配给能够处理此事件的任务，然后此任务判断事件的类型，调用相应的事件处理程序进行处理。


按键在我们的应用里面应该属于硬件资源，所以OSAL理应为我们提供使用和管理这些硬件的服务。稍微留意一下我们之前说过的tasksArr这样一个数组，它保存了所有任务的事件处理函数。我们从中发现了一个很重要的信息：Hal_ProcessEvent。HAL（Hardware Abstraction Layer）翻译为“硬件抽象层”。许多人在这里经常把将BLE的硬件抽象层与物理层混为一谈。在这里，我们应该将BLE的硬件抽象层与物理层区分开来。硬件抽象层所包含的范围是我们当前硬件电路上面所有对于系统可用的设备资源。而物理层则是针对无线通信而言，它所包含的仅限于支持无线通讯的硬件设备。
　　通过这个重要的信息，我们可以得出这样一个结论：OSAL将硬件的管理也作为一个任务来处理。
